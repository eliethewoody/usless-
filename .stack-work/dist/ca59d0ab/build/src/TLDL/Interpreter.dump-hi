
==================== FINAL INTERFACE ====================
2017-11-02 15:23:26.3184983 UTC

interface usless-0.1.0.0-Lqc2BaLkUqq9LG61fMYzNm:TLDL.Interpreter 8002
  interface hash: ce52b9613c997a03365758793d1675f7
  ABI hash: c12b2cdddcbc9e61de6b2467dea4a2fc
  export-list hash: f33ef6a9c9857498d327f8f9f1183a60
  orphan hash: c2b1fccfdbdb50be59f1e3e88f26d59e
  flag hash: 2d02f76485a01b51be1a9bed2ed898f4
  sig of: Nothing
  used TH splices: False
  where
exports:
  TLDL.Interpreter.loadState
  TLDL.Interpreter.peek
  TLDL.Interpreter.poke
  TLDL.Interpreter.replaceNth
  TLDL.Interpreter.saveCurrentState
module dependencies: USLS.MOperators USLS.Usless
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
                      split-0.2.3.2@split-0.2.3.2-CJl40zTyCIV16Pr60nb7CT
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.Foldable 254e836c2d813d34e47feb29bb8d40ed
import  -/  base-4.9.1.0:GHC.Base 4caea1123ecf4b46e27cbccd6d279377
import  -/  base-4.9.1.0:GHC.List d11eb227c1c6fbfd89bb781d72eaea0d
import  -/  base-4.9.1.0:GHC.Num 38b8aac8807c096c7f3ca3c1eff02939
import  -/  base-4.9.1.0:GHC.Show eca5834daba3b6a2bbbe64ab52056707
import  -/  base-4.9.1.0:Prelude 74b3e204395920329f6de9d97206abe9
import  -/  base-4.9.1.0:System.IO 5daf3f384209c11d9566e3409af8ec5d
import  -/  base-4.9.1.0:Text.Read 3cc85705eeac93ec93da7f5edfd7bc15
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  split-0.2.3.2@split-0.2.3.2-CJl40zTyCIV16Pr60nb7CT:Data.List.Split 272c5cfa667e04d85d90f02a3d135474
import  -/  split-0.2.3.2@split-0.2.3.2-CJl40zTyCIV16Pr60nb7CT:Data.List.Split.Internals 0d2d4848ca60317e9a83da501ccf16c9
import  -/  USLS.MOperators 23711402a9595693228568796da9ae04
  exports: a2f24ef812e84bc4a9bae42293d6833f
import  -/  USLS.Usless 6ffb6a6cf460d2f9fa7834bbf321e167
  exports: 1c78333baa4d79823057a352f17c3239
  MRAM d7204a6b7f62b1ba2fad52531a1b39ca
  MultiplexerInput aaec5258262eeca315161789dd59336e
  MultiplexerInput a7e5add60066491a06b506109692147f
  Negative 4a017c0b0c6b5dc7f8169e416290b92c
  Positive 6ab821ec23b1170f419f8b06d354ca9d
  Signal dc9f1b76e22bf10131d08d969ae66af3
  Zero 60e1a5bac99bef19c660d3260e832c83
  negativeInput 88a89cc03f63b03197f8f47d9656ded2
  positiveInput c17262a292cd4c07208fd862d3d8385b
  zeroInput 0e0c9e037fcf3dae6ab6392fd5c79bec
a126894246d9bbf432aec42ccd1a23e8
  $sread :: GHC.Base.String -> USLS.Usless.Signal
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (s :: GHC.Base.String) ->
                 case Text.Read.readEither
                        @ USLS.Usless.Signal
                        USLS.Usless.$fReadSignal
                        s of wild {
                   Data.Either.Left x
                   -> GHC.Err.errorWithoutStackTrace
                        @ 'GHC.Types.PtrRepLifted
                        @ USLS.Usless.Signal
                        x
                   Data.Either.Right y -> y }) -}
276164d261673834260b4848676a28cb
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   TLDL.Interpreter.$trModule2
                   TLDL.Interpreter.$trModule1) -}
bcc89573d34ae5e2d10c87df4252dbdb
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "TLDL.Interpreter"#) -}
442a56e9fc028ed3b6be3a6deb7d2809
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "usless-0.1.0.0-Lqc2BaLkUqq9LG61fMYzNm"#) -}
9fe8e9ce979eb2cb6fb47028916ec3aa
  $wlvl ::
    USLS.Usless.Signal
    -> USLS.Usless.Signal
    -> USLS.Usless.Signal
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 4, Strictness: <L,1*U><L,1*U><L,1*U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: USLS.Usless.Signal)
                   (ww1 :: USLS.Usless.Signal)
                   (ww2 :: USLS.Usless.Signal)
                   (w :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 System.IO.writeFile1
                   TLDL.Interpreter.saveCurrentState2
                   (let {
                      arg :: [GHC.Types.Char]
                      = GHC.Base.++
                          @ GHC.Types.Char
                          TLDL.Interpreter.loadState5
                          (case ww1 of wild {
                             USLS.Usless.Positive
                             -> GHC.Base.++
                                  @ GHC.Types.Char
                                  USLS.Usless.$fReadSignal15
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     TLDL.Interpreter.loadState5
                                     (case ww2 of wild1 {
                                        USLS.Usless.Positive -> USLS.Usless.$fReadSignal15
                                        USLS.Usless.Zero -> USLS.Usless.$fReadSignal12
                                        USLS.Usless.Negative -> USLS.Usless.$fReadSignal9 }))
                             USLS.Usless.Zero
                             -> GHC.Base.++
                                  @ GHC.Types.Char
                                  USLS.Usless.$fReadSignal12
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     TLDL.Interpreter.loadState5
                                     (case ww2 of wild1 {
                                        USLS.Usless.Positive -> USLS.Usless.$fReadSignal15
                                        USLS.Usless.Zero -> USLS.Usless.$fReadSignal12
                                        USLS.Usless.Negative -> USLS.Usless.$fReadSignal9 }))
                             USLS.Usless.Negative
                             -> GHC.Base.++
                                  @ GHC.Types.Char
                                  USLS.Usless.$fReadSignal9
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     TLDL.Interpreter.loadState5
                                     (case ww2 of wild1 {
                                        USLS.Usless.Positive -> USLS.Usless.$fReadSignal15
                                        USLS.Usless.Zero -> USLS.Usless.$fReadSignal12
                                        USLS.Usless.Negative -> USLS.Usless.$fReadSignal9 })) })
                    } in
                    case ww of wild {
                      USLS.Usless.Positive
                      -> GHC.Base.++ @ GHC.Types.Char USLS.Usless.$fReadSignal15 arg
                      USLS.Usless.Zero
                      -> GHC.Base.++ @ GHC.Types.Char USLS.Usless.$fReadSignal12 arg
                      USLS.Usless.Negative
                      -> GHC.Base.++ @ GHC.Types.Char USLS.Usless.$fReadSignal9 arg })
                   w) -}
6491b3986ed82b90d2d145d2dcb46318
  $wpoke ::
    USLS.Usless.MRAM
    -> GHC.Prim.Int#
    -> USLS.Usless.Signal
    -> USLS.Usless.Signal
    -> [USLS.Usless.MultiplexerInput]
  {- Arity: 4, Strictness: <S,U><S,U><S,U><L,U>, Inline: [0],
     Unfolding: (\ (w :: USLS.Usless.MRAM)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: USLS.Usless.Signal)
                   (w2 :: USLS.Usless.Signal) ->
                 let {
                   $j :: GHC.Prim.Void# -> [USLS.Usless.MultiplexerInput]
                     {- Arity: 1, Strictness: <L,A> -}
                   = \ (w3 :: GHC.Prim.Void#)[OneShot] ->
                     case w1 of wild {
                       USLS.Usless.Positive -> TLDL.Interpreter.poke1
                       USLS.Usless.Zero
                       -> case TLDL.Interpreter.$wreplaceNth
                                 @ USLS.Usless.MultiplexerInput
                                 ww
                                 (case GHC.List.$w!!
                                         @ USLS.Usless.MultiplexerInput
                                         w
                                         ww of wild1 { USLS.Usless.MultiplexerInput ds ds1 ds2 ->
                                  USLS.Usless.MultiplexerInput ds w2 ds2 })
                                 w of ww1 { (#,#) ww2 ww3 ->
                          GHC.Types.: @ USLS.Usless.MultiplexerInput ww2 ww3 }
                       USLS.Usless.Negative
                       -> case TLDL.Interpreter.$wreplaceNth
                                 @ USLS.Usless.MultiplexerInput
                                 ww
                                 (case GHC.List.$w!!
                                         @ USLS.Usless.MultiplexerInput
                                         w
                                         ww of wild1 { USLS.Usless.MultiplexerInput ds ds1 ds2 ->
                                  USLS.Usless.MultiplexerInput w2 ds1 ds2 })
                                 w of ww1 { (#,#) ww2 ww3 ->
                          GHC.Types.: @ USLS.Usless.MultiplexerInput ww2 ww3 } }
                 } in
                 case w1 of wild {
                   USLS.Usless.Positive
                   -> case TLDL.Interpreter.$wreplaceNth
                             @ USLS.Usless.MultiplexerInput
                             ww
                             (case GHC.List.$w!!
                                     @ USLS.Usless.MultiplexerInput
                                     w
                                     ww of wild1 { USLS.Usless.MultiplexerInput ds ds1 ds2 ->
                              USLS.Usless.MultiplexerInput ds ds1 w2 })
                             w of ww1 { (#,#) ww2 ww3 ->
                      GHC.Types.: @ USLS.Usless.MultiplexerInput ww2 ww3 }
                   USLS.Usless.Zero -> $j GHC.Prim.void#
                   USLS.Usless.Negative -> $j GHC.Prim.void# }) -}
a26cd174b839af5d28512142e2da12ec
  $wreplaceNth :: GHC.Prim.Int# -> a -> [a] -> (# a, [a] #)
  {- Arity: 3, Strictness: <S,1*U><L,U><S,1*U>, Inline: [0] -}
028e2e7a134f0093e16db2daa5049ef3
  loadState :: GHC.Base.String -> USLS.Usless.MRAM
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (dump :: GHC.Base.String) ->
                 GHC.Base.build
                   @ USLS.Usless.MultiplexerInput
                   (\ @ b1
                      (c :: USLS.Usless.MultiplexerInput -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ [GHC.Types.Char]
                      @ b1
                      (GHC.Base.mapFB
                         @ USLS.Usless.MultiplexerInput
                         @ b1
                         @ [GHC.Types.Char]
                         c
                         TLDL.Interpreter.loadState2)
                      n
                      (Data.List.Split.Internals.splitOn
                         @ GHC.Types.Char
                         GHC.Classes.$fEqChar
                         TLDL.Interpreter.loadState1
                         dump))) -}
42d1aaf859abcc2317188124b6e16bc1
  loadState1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "\n"#) -}
aa6d8177f60aa92806fa8123f4ad9d96
  loadState2 :: [GHC.Types.Char] -> USLS.Usless.MultiplexerInput
  {- Arity: 1, Strictness: <L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [GHC.Types.Char]) ->
                 case GHC.Base.map
                        @ [GHC.Types.Char]
                        @ USLS.Usless.Signal
                        TLDL.Interpreter.$sread
                        (TLDL.Interpreter.loadState4 w) of wild {
                   [] -> TLDL.Interpreter.loadState3
                   : n ds
                   -> case ds of wild1 {
                        [] -> TLDL.Interpreter.loadState3
                        : o ds1
                        -> case ds1 of wild2 {
                             [] -> TLDL.Interpreter.loadState3
                             : p ds2 -> USLS.Usless.MultiplexerInput n o p } } }) -}
414d9a59c48418e2320a1e6027e51a36
  loadState3 :: USLS.Usless.MultiplexerInput
  {- Strictness: x -}
984afb3640723e29893bc391739a6283
  loadState4 :: [GHC.Types.Char] -> [[GHC.Types.Char]]
  {- Unfolding: (Data.List.Split.Internals.splitOn
                   @ GHC.Types.Char
                   GHC.Classes.$fEqChar
                   TLDL.Interpreter.loadState5) -}
7a461b4a65ad4947d5227394b5d899a0
  loadState5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "."#) -}
2b612380ffafe7424288d5ca629d64d6
  peek ::
    USLS.Usless.MRAM -> GHC.Types.Int -> USLS.Usless.MultiplexerInput
  {- Arity: 2, Strictness: <S,1*U><S(S),1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                (GHC.List.!! @ USLS.Usless.MultiplexerInput) -}
6917ff00fbf5df2db9e08712fde8777a
  poke ::
    USLS.Usless.MRAM
    -> GHC.Types.Int
    -> USLS.Usless.Signal
    -> USLS.Usless.Signal
    -> USLS.Usless.MRAM
  {- Arity: 4, Strictness: <S,U><S(S),U(U)><S,U><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: USLS.Usless.MRAM)
                   (w1 :: GHC.Types.Int)
                   (w2 :: USLS.Usless.Signal)
                   (w3 :: USLS.Usless.Signal) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 TLDL.Interpreter.$wpoke w ww1 w2 w3 }) -}
eef05a07ca775cd8955434ff0f240482
  poke1 :: USLS.Usless.MRAM
  {- Strictness: x -}
0a523f517a8e21208759fd2ecb48cca1
  replaceNth :: GHC.Types.Int -> a -> [a] -> [a]
  {- Arity: 3, Strictness: <S(S),1*U(1*U)><L,U><S,1*U>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a (w :: GHC.Types.Int) (w1 :: a) (w2 :: [a]) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case TLDL.Interpreter.$wreplaceNth
                        @ a
                        ww1
                        w1
                        w2 of ww2 { (#,#) ww3 ww4 ->
                 GHC.Types.: @ a ww3 ww4 } }) -}
76ff04b21dfc18fa09ec15112f7c3b75
  saveCurrentState :: USLS.Usless.MRAM -> [GHC.Types.IO ()]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (chip :: USLS.Usless.MRAM) ->
                 GHC.Base.build
                   @ (GHC.Types.IO ())
                   (\ @ b1
                      (c :: GHC.Types.IO () -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ USLS.Usless.MultiplexerInput
                      @ b1
                      (GHC.Base.mapFB
                         @ (GHC.Types.IO ())
                         @ b1
                         @ USLS.Usless.MultiplexerInput
                         c
                         TLDL.Interpreter.saveCurrentState1
                           `cast`
                         (<USLS.Usless.MultiplexerInput>_R
                          ->_R Sym (GHC.Types.N:IO[0] <()>_R)))
                      n
                      chip)) -}
54f2c70d00ca68fab2e1170f2f7acfbc
  saveCurrentState1 ::
    USLS.Usless.MultiplexerInput
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <S,1*U(1*U,1*U,1*U)><S,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: USLS.Usless.MultiplexerInput)
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case w of ww { USLS.Usless.MultiplexerInput ww1 ww2 ww3 ->
                 TLDL.Interpreter.$wlvl ww1 ww2 ww3 w1 }) -}
6ed605f44a416ba0be1607c9f9f24127
  saveCurrentState2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "dump.!"#) -}
"SPEC/TLDL.Interpreter read @ Signal" [ALWAYS] forall ($dRead :: GHC.Read.Read
                                                                   USLS.Usless.Signal)
  Text.Read.read @ USLS.Usless.Signal $dRead
  = TLDL.Interpreter.$sread
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

